## Fractional Knapsack
- Can hold weight of up to `w` and may select from `n` items
- Each item has a weight `wi` and value `vi`
- You may take any fraction of each item
- What is the maximum total value
- Worth the change if `vi/wi < vj/wj`
``` python
from fractions import Fraction
def frac_knapsack(capacity: int, items: list[tuple[int, int]]) -> Fraction:
	# Sort by value to weight ratio, highest first
	items.sort(key=lambda x: Fraction(x[1], x[0]), reverse=True)
	weight = 0
	result = Fraction(0)
		for wi, vi in items:
		d = min(capacity - weight, wi) # Take as much of item i as we can
		weight += d
		result += d * Fraction(vi, wi)
		if weight == capacity:
			break
	return result
```

## Greedy 
- A greedy strategy is a "short-sighted", making a locally optimal choice without considering the consequences
- Requires optimal substructure, as after making a greedy choice we will have a new subproblem for which the greedy must still work

## Activity Selection
- Consider a set $A=\{a_1, a_2, ..., a_n\}$ of activities
- Each activity is an interval $a_i=[s_i,f_i)=\{t|s_i <= t <= f_i\}$ with start time $s_i$ and finish $f_i$
- A pair of activities are compatible iff they do not intersect
- Find a maximal subset
#### Greedy Algorithm for Activities
- Start with all activities available
- Greedily select activity that finishes first
- Discard activities
- Repeat
``` python
def activity_selection(activities: list[tuple[int, int]]) -> list:
	activities.sort(key=lambda a: a[1]) # Sort by finish time
	result = []
	t, _ = activities[0] # Start from earliest time
	for ai in activities:
		si, fi = ai
		if si >= t: # Otherwise we skip ai, discarding it
			result.append(ai)
			t = fi
	return result
```
`O(NlgN)`
+