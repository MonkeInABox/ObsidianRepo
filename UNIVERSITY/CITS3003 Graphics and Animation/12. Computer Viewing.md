# The OpenGL Camera
-  Initially the object and camera frames are the same, the camera is at the origin and points in the negative z direction
- If we want to visualise objects that have both positive and negative z values, we can either move objects in the negative z direction (translate world frame) or move the camera in the positive z direction (translate the camera frame)
``` cpp
void gluLookAt(eyeX, eyeY, eyeZ, centreX, centreY, centreZ, upX, upY, upZ);
```
## View Volumes
- Orthogonal projection
	- Parallel lines from each object vertex 
	- Projection centre is infinite
	- Set z component to 0
$$M=\begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}$$

- Perspective projection
	- d is the focal length and finite
	$$\frac{x_{p}}{ d}= \frac{x}{z}, \frac{y_{p}}{d}= \frac{y}{z}, x_{p}= d$$
- Near and far clipping planes
- FOV
- Aspect ratio
Model-view brings object into eye coordinate space then:
Projection matrix for perspective or parallel to apply perspective then:
Perspective division to put perspective back to original coordinates
``` cpp
//sets viewing volume for orthographic
void glOrtho(left, right, bottom, top, near, far);
mat4 Ortho(left, right, bottom, top, near, far);
//moves centre to origin and scaes to have side lengths

//Perspective viewing
mat4 Frustum(left, right, bottom, top, near, far);
mat4 Perspective(fovy, aspect, near, far);
//aspect = w/h
```

## Complete Viewing Pipeline
- Model (orient object) -> View (orient camera or world) -> Projection
- $P * V * M_{i}* O_{i}$

## `glMatrixMode()`
- Recall OpenGL is a state machine
- `glMatrixMode()` defines the current matrix
	- `GL_MODELVIEW`
	- `GL_PROJECTION`
	- `GL_TEXTURE`
	- `GL_COLOR`
- `glGet(GL_MATRIX_MODE)` will return current matrix mode
``` cpp
glMatrixMode(GL_PROJECTION);
glLoadIdentity(); //clear matrix
glFrustum(-1.0, -1.0, -1.0, 1.5, 20.0);
```